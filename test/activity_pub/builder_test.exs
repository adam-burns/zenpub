defmodule ActivityPub.BuilderTest do
  use MoodleNet.DataCase, async: true

  alias ActivityPub.Builder

  alias ActivityPub.{Entity, BuildError}
  import ActivityPub.Guards

  @context ["https://www.w3.org/ns/activitystreams", %{"@language" => "es"}]

  describe "new" do
    test "builds new empty objects" do
      assert {:ok, entity} = Builder.new()
      assert is_entity(entity)
      assert has_aspect(entity, ActivityPub.ObjectAspect)
      assert Entity.status(entity) == :new
      assert Entity.local?(entity) == true

      assert entity[:"@context"] == ActivityPub.Context.default()
      assert entity.content == %{}
      assert entity.name == %{}
      assert entity.summary == %{}

      assert %{
               id: nil,
               duration: nil,
               media_type: nil,
               end_time: nil,
               published: nil,
               start_time: nil,
               updated: nil,
               bcc: [],
               bto: [],
               cc: [],
               to: [],
               attachment: [],
               attributed_to: [],
               audience: [],
               context: [],
               generator: [],
               icon: [],
               image: [],
               # in_reply_to: nil,
               location: [],
               # replies: nil,
               tag: []
             } = entity
    end

    test "works with date fields" do
      params = %{
        end_time: "2015-01-01T06:00:00-08:00"
      }

      assert {:ok, entity} = Builder.new(params)

      assert %DateTime{
               year: 2015,
               month: 1,
               day: 1,
               hour: 14,
               minute: 0,
               second: 0
             } = entity.end_time
    end

    test "works with translatable fields" do
      params = %{
        "@context" => @context,
        "content" => "string"
      }

      assert {:ok, entity} = Builder.new(params)
      assert %{content: %{"es" => "string"}} = entity

      content = %{"en" => "string", "fr" => "string"}

      params = %{
        "@context" => @context,
        "content" => content
      }

      assert {:ok, entity} = Builder.new(params)
      assert %{content: ^content} = entity
    end

    test "supports extra fields" do
      assert {:ok, entity} = Builder.new(extra_field: "extra")
      assert %{"extra_field" => "extra"} = entity
    end

    test "builds assocs" do
      params = %{
        "@context": @context,
        name: "test",
        context: %{
          content: "A context"
        }
      }

      assert {:ok, entity} = Builder.new(params)

      assert %{
               name: %{"es" => "test"},
               context: [
                 %{
                   content: %{"es" => "A context"}
                 }
               ]
             } = entity

      assert entity[:"@context"] == hd(entity.context)[:"@context"]
    end

    test "returns error" do
      assert {:error, error} = Builder.new(updated: "not_a_date")
      assert %BuildError{path: ["updated"], message: "is invalid", value: "not_a_date"} = error
    end

    test "returns inner error" do
      map = %{context: %{updated: "not_a_date"}}
      assert {:error, error} = Builder.new(map)

      assert %BuildError{
               path: ["context.0", "updated"],
               message: "is invalid",
               value: "not_a_date"
             } = error
    end

    @tag :skip
    test "works with functional associations" do
      params = %{
        type: "Person",
        followers: []
      }

      assert {:error, error} = Builder.new(params)

      assert %BuildError{
               path: ["followers"],
               message: "is invalid",
               value: []
             } = error

      params = %{
        type: "Person",
        followers: "https://moodle.net/alexcastano/followers"
      }

      assert {:ok, entity} = Builder.new(params)
      assert is_entity(entity.followers)
    end

    @tag :skip
    test "verifies the associations type" do
      params = %{
        type: "Person",
        followers: %{
          type: "Object"
        }
      }

      assert {:error, error} = Builder.new(params)

      assert %BuildError{
               path: ["followers"],
               message: "has invalid type: [\"Object\"], expected: \"Collection\""
             } = error
    end

    # FIXME !!! To build CollectionPage
    @tag :skip
    test "fails creating autogenerated fields" do
      params = %{likers_count: 1}

      assert {:error, error} = Builder.new(params)

      assert %BuildError{
               path: ["likers_count"],
               message: "is an autogenerated field, but data is received",
               value: 1
             } = error
    end

    test "fails creating autogenerated associations" do
      params = %{
        type: "Person",
        followers: []
      }

      assert {:error, error} = Builder.new(params)

      assert %BuildError{
               path: ["followers"],
               message: "is an autogenerated association, but data is received",
               value: []
             } = error
    end

    test "allows referencing by id" do
      assert {:ok, entity} = Builder.new(%{context: "https://moodle.net/group/1"})
      assert hd(entity.context) |> Entity.status() == :not_loaded
    end

    test "builds actors" do
      params = %{
        type: "Person",
        name: "Alex",
        preferred_username: "alexcastano"
      }

      assert {:ok, entity} = Builder.new(params)

      assert %{
               preferred_username: "alexcastano",
               type: ["Object", "Actor", "Person"],
               name: %{"und" => "Alex"}
             } = entity

      assert entity.inbox
      assert has_type(entity.inbox, "Collection")
      assert entity.outbox
      assert has_type(entity.outbox, "Collection")
      assert entity.following
      assert has_type(entity.following, "Collection")
      assert entity.followers
      assert has_type(entity.followers, "Collection")
      assert entity.liked
      assert has_type(entity.liked, "Collection")
    end

    test "builds activity" do
      params = %{
        "@context": "https://www.w3.org/ns/activitystreams",
        type: "Create",
        to: ["https://chatty.example/ben/"],
        actor: "https://social.example/alyssa/",
        object: %{
          type: "Note",
          attributedTo: "https://social.example/alyssa/",
          to: ["https://chatty.example/ben/"],
          content: "Say, did you finish reading that book I lent you?"
        }
      }

      assert {:ok, entity} = Builder.new(params)
      # TODO
      assert %{} = entity
    end

    @tag :skip
    # FIXME
    test "allows receiving just ID and new objects" do
      params = %{
        attributed_to: [
          %{
            id: "https://alex.gitlab.com",
            type: "Person",
            name: "Alex",
            inbox: "https://alex.gitlab.com/inbox",
            outbox: "https://alex.gitlab.com/outbox"
          },
          "https://doug.gitlab.com"
        ]
      }

      assert {:ok, entity} = Builder.new(params)
    end
  end

  def insert!(params \\ %{}) do
    assert {:ok, e} = ActivityPub.new(params)
    assert {:ok, e} = ActivityPub.insert(e)
    e
  end

  describe "update" do
    test "cannot change id" do
      entity = insert!()
      assert {:error, error} = Builder.update(entity, id: "new_id")
      assert %BuildError{path: [:id], value: "new_id", message: "cannot be changed"} = error

      assert {:ok, ^entity} = Builder.update(entity, id: entity.id)
    end

    test "cannot change type" do
      entity = insert!()
      assert {:error, error} = Builder.update(entity, type: "Link")
      assert %BuildError{path: [:type], value: "Link", message: "cannot be changed"} = error

      assert {:ok, ^entity} = Builder.update(entity, type: entity.type)
    end

    test "works with language values" do
      entity = insert!(%{"@context" => @context})

      attrs = [nameMap: %{"en" => "MoodleNet"}]
      assert {:ok, updated} = Builder.update(entity, attrs)
      assert updated.name == %{"en" => "MoodleNet"}

      attrs = [name: "MoodleNet"]
      assert {:ok, updated} = Builder.update(entity, attrs)
      assert updated.name == %{"es" => "MoodleNet"}

      attrs = [name: nil]
      assert {:ok, updated} = Builder.update(entity, attrs)
      assert updated.name == %{}
    end

    test "works with datetime value" do
      entity = insert!()
      attrs = [end_time: "2015-01-01T06:00:00-08:00"]
      assert {:ok, updated} = Builder.update(entity, attrs)

      assert %DateTime{
               year: 2015,
               month: 1,
               day: 1,
               hour: 14,
               minute: 0,
               second: 0
             } = updated.end_time
    end

    test "works with actors" do
      entity = insert!(type: "Person")
      attrs = [preferred_username: "alex"]

      assert {:ok, updated} = Builder.update(entity, attrs)
      assert updated.preferred_username == "alex"
    end

    test "avoids update associations" do
      entity = insert!()
      context = insert!()
      attrs = [context: context]

      assert {:error, error} = Builder.update(entity, attrs)
      assert %BuildError{path: [:context], message: "association cannot be updated"} = error
    end

    test "updates extension fields" do
      entity = insert!(extension_field: "extension")

      attrs = [extension_field: "extra"]
      assert {:ok, updated} = Builder.update(entity, attrs)
      assert updated["extension_field"] == "extra"

      attrs = [extension_field: nil]
      assert {:ok, updated} = Builder.update(entity, attrs)
      refute Map.has_key?(updated, "extension_field")
    end
  end
end
