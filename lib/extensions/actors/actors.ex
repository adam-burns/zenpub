# SPDX-License-Identifier: AGPL-3.0-only
defmodule MoodleNet.Actors do
  @doc """
  A Context for dealing with Actors.
  Actors come in several kinds:

  * Users
  * Communities
  * Collections
  """

  @replacement_regex ~r/[^a-zA-Z0-9-]/
  @wordsplit_regex ~r/[\t\n \_\|\(\)\#\@\.\,\;\[\]\/\\\}\{\=\*\&\<\>\:]/

  alias MoodleNet.Actors.{Actor, NameReservation, Queries}
  alias MoodleNet.Repo
  alias MoodleNet.Users.User
  alias Ecto.Changeset

  def one(filters), do: Repo.single(Queries.query(Actor, filters))

  @doc "true if the provided preferred_username is available to register"
  @spec is_username_available?(username :: binary) :: boolean()
  def is_username_available?(username) when is_binary(username) do
    is_nil(Repo.get(NameReservation, username))
  end

  @doc "Inserts a username reservation if it has not already been reserved"
  def reserve_username(username) when is_binary(username) do
    Repo.insert(NameReservation.changeset(username))
  end

  # FIXME
  #  @doc "creates a new actor with one of two possible usernames"
  # def create(
  #       %{
  #         :preferred_username => preferred_username,
  #         :alternative_username => alternative_username
  #       } = attrs
  #     )
  #     when is_map(attrs) do
  #   IO.inspect(is_username_available?(preferred_username))
  #   IO.inspect(is_username_available?(alternative_username))

  #   if(is_username_available?(preferred_username)) do
  #     attrs =
  #       attrs
  #       |> Map.put("preferred_username", alternative_username)
  #   end

  #   attrs =
  #     attrs
  #     |> Map.delete(:alternative_username)

  #   IO.inspect(attrs)

  #   create(attrs)
  # end

  @doc "creates a new actor from the given attrs"
  @spec create(attrs :: map) :: {:ok, Actor.t()} | {:error, Changeset.t()}
  def create(attrs) when is_map(attrs) do
    # attrs = Map.put(attrs, :preferred_username, atomise_username(Map.get(attrs, :preferred_username)))
    Repo.transact_with(fn ->
      with {:ok, actor} <- Repo.insert(Actor.create_changeset(attrs)) do
        if is_nil(actor.peer_id) do
          case reserve_username(attrs.preferred_username) do
            {:ok, _} -> {:ok, actor}
            _ -> {:error, "Username already taken"}
          end
        else
          {:ok, actor}
        end
      end
    end)
  end

  @doc """
  creates a new actor from the given attrs with an automatically generated username
  """
  @spec auto_create(attrs :: map) :: {:ok, Actor.t()} | {:error, Changeset.t()}
  def auto_create(attrs) when is_map(attrs) do
    attrs
    |> Map.update(:preferred_username, nil, &atomise_username/1)
    |> create()
  end

  @spec update(user :: User.t(), actor :: Actor.t(), attrs :: map) ::
          {:ok, Actor.t()} | {:error, Changeset.t()}
  def update(%User{}, %Actor{} = actor, attrs) when is_map(attrs) do
    Repo.update(Actor.update_changeset(actor, attrs))
  end

  def update(_, actor, _) do
    # FIXME
    actor
  end

  @spec delete(user :: User.t(), actor :: Actor.t()) :: {:ok, Actor.t()} | {:error, term}
  def delete(%User{}, %Actor{} = actor), do: Repo.delete(actor)

  def update_by(%User{}, filters, updates) do
    Repo.update_all(Queries.query(Actor, filters), set: updates)
  end

  # When the username is autogenerated, we have to scrub it
  def atomise_username(username) when is_nil(username), do: nil

  def atomise_username(username) do
    Slugger.slugify(username)
    # |> String.replace(@wordsplit_regex, "-")
    # |> String.replace(@replacement_regex, "")
    # |> String.replace(~r/--+/, "-")
  end

  def prepare_username(%{:preferred_username => preferred_username} = attrs)
      when not is_nil(preferred_username) and preferred_username != "" do
    Map.put(attrs, :preferred_username, atomise_username(preferred_username))
  end

  # if no username set, autocreate from name
  def prepare_username(%{:name => name} = attrs)
      when not is_nil(name) and name != "" do
    Map.put(attrs, :preferred_username, atomise_username(Map.get(attrs, :name)))
  end

  def prepare_username(attrs) do
    attrs
  end

  def display_username(obj, full_hostname \\ false)

  def display_username(%MoodleNet.Communities.Community{} = obj, full_hostname) do
    display_username(obj, full_hostname, "&")
  end

  def display_username(%MoodleNet.Collections.Collection{} = obj, full_hostname) do
    display_username(obj, full_hostname, "+")
  end

  def display_username(%CommonsPub.Tag.Taggable{} = obj, full_hostname) do
    display_username(obj, full_hostname, "+")
  end

  def display_username(%CommonsPub.Tag.Category{} = obj, full_hostname) do
    display_username(obj, full_hostname, "+")
  end

  def display_username(%MoodleNet.Users.User{} = obj, full_hostname) do
    display_username(obj, full_hostname, "@")
  end

  def display_username(obj, full_hostname) do
    display_username(obj, full_hostname, "@")
  end

  def display_username(%{"preferred_username" => uname}, full_hostname, prefix)
      when not is_nil(uname) do
    "#{prefix}#{uname}"
  end

  def display_username(%{preferred_username: uname}, full_hostname, prefix)
      when not is_nil(uname) do
    "#{prefix}#{uname}"
  end

  def display_username(
        %{actor: %Actor{peer_id: nil, preferred_username: uname}},
        true,
        prefix
      ) do
    "#{prefix}#{uname}" <> "@" <> MoodleNet.Instance.hostname()
  end

  def display_username(
        %{actor: %Actor{peer_id: nil, preferred_username: uname}},
        false,
        prefix
      )
      when not is_nil(uname) do
    "#{prefix}#{uname}"
  end

  def display_username(
        %{character: %{actor: %Actor{peer_id: nil, preferred_username: uname} = actor}},
        full_hostname,
        prefix
      ) do
    display_username(
      %{actor: actor},
      full_hostname,
      prefix
    )
  end

  def display_username(%{actor: %Actor{preferred_username: uname}}, full_hostname, prefix)
      when not is_nil(uname) do
    "#{prefix}#{uname}"
  end

  def display_username(%{actor_id: _actor_id} = obj, full_hostname, prefix) do
    obj = MoodleNetWeb.Helpers.Common.maybe_preload(obj, :actor)
    display_username(obj, full_hostname, prefix)
  end

  def display_username(obj, _, _) do
    IO.inspect(could_not_display_username: obj)
    ""
  end

  def obj_load_actor(%{actor: actor} = obj) do
    Repo.preload(obj, :actor)
  end

  def obj_load_actor(%{character: %{actor: actor} = character}) do
    Repo.preload(character, :actor)
  end

  def obj_load_actor(%{character: character} = obj) do
    Repo.preload(obj, character: :actor)
  end

  def obj_actor(%{actor: actor} = obj) do
    obj_load_actor(obj).actor
  end

  def obj_actor(%{character: %{actor: actor} = character} = obj) do
    obj_load_actor(obj).actor
  end

  def obj_actor(%{character: character} = obj) do
    obj_load_actor(obj).character.actor
  end
end
